---
marp: true
paginate: true

---
<style>
  pre {
  line-height: 150%;
}

blockquote {
  background-color: black;
  color: white;
  padding:1em;
  font-family: "Arial";
  font-size:48px
}
</style>

---
# Prepare
- delete cookies
- toggle auto hide
- remove detect indentation
- disable gitlens
- Zen mode
- make sure network tab has only method and is correctly scaled
- Size the terminal window
- clear terminal window
- Make sure that the file explorer folders are collapsed and you can see frontend and backend
- open browser at github.com/remult/react-todo.
---
# Short remult demo
---
>Hi I’m Noam Honig, and in this short video I’ll introduce you to Remult.

>Remult is a CRUD framework for full-stack TypeScript.

---
> Let me show you what Remult can do using this example todo app, 

goto url on browser

> which you can find at github.com/remult/react-todo.

---
[ open terminal for npm run dev]

>I’ve already cloned this project and run “npm install” so I can start by running 
“the dev npm script”.

>This is going to start both sides of this todo app - the frontend single-page-application, and the backend server that exposes a REST API.

---

[ focus on left file explorer BE FE ]

>Now, if we look at the code base we can see it has a Backend folder and a Frontend folder, 
>
>but, it also contains a “shared” folder, for code that is shared between the frontend and the backend.

--- 
>You can use Remult together with any JavaScript web framework, any JavaScript frontend framework, and a wide selection of databases. 
This also means you can deploy apps that use Remult to any Node.js server or serverless cloud provider.

---

> For this demo I’ve used a React frontend, 
> 
> an Express server, and a simple JSON file database.

[ goto browser 3000]

> Let’s go to localhost:3000 to see the todo app.
---


> There it is so let’s add a few groceries to the list. 

[ insert Bananas and Apples ]

> We need Bananas, and apples, 

---

[ open network tab]

> now let’s see what’s going over the network while I’m doing this

[ insert Oranges]

> Oranges, cake

> you can see that everything here is simple REST API requests

---
> I can tick them, I can update, I can delete… 

> Again standard REST API requests are handled by the backend.

---

> Let’s review the source code.

[ open task.ts ]

> First, let’s have a look at the Task entity class.

> Using Remult, a TypeScript entity class becomes a single-source-of-truth for everything our application needs around that entity.

---
[ highlight entity decorator ]

> The Entity decorator tells Remult that this class will be used as a model for both frontend and backend code, so Remult should create CRUD API endpoints and a database table for this entity. 

---

[ highlight allow api crud ]

> As you can see I’ve told Remult to allow all CRUD operations for the Task entity. Later, I’ll restrict that.

--- 

[ highlight field decorators ]

> We also have decorators for each field to control its datatype and behavior.

---

[ goto backend/index => highlight remult express ]

> On the backend, all we have is a simple Express server, and Remult’s Express middleware, where the Task entity is registered.

--- 

[ goto vite.config.ts (last file)]

> On the frontend I’ve used the proxy feature of vite dev server,
as you can see here, 
>to forward all requests sent to '/api' to the backend server that is listening on port 3002.

---

[ app.tsx, collapse terminal and bar, highlight remult.repo ] 

> On the  App.tsx, we ask Remult to provide us with a repository object for the Task entity. We use this taskRepo object to interact with the backend.

[ highlight useEffect find ]

>Here we call the taskRepo-find method which loads and returns all the todos from the backend.

---

[highlight network tab for get request]

> You can see the GET request generated by this “find” call over here.

---

[ scroll to add task function, and highlight repo.insert]

>Here we have the addTask function which uses taskRepo-insert to send a POST request to our REST API backend, which will trigger the creation of a new task in the database. Remult does all that without us having to write any code.

---

[ scroll to setCompleted ]

> Moving on we can see the setCompleted function that is triggered when I tick these checkboxes. setCompleted uses taskRepo-save to save this change all the way to the database.

---

[ scroll the deleteTask ]

> Here we have the deleteTask function that deletes a task using taskRepo-delete.

---

>So, as you can see, using Remult I get full-stack, type-safe CRUD for this whole app, and I didn’t have to write or generate any boilerplate plumbing code. All I needed to do is define the Task entity, register it on the backend, and use Remult’s Repository object on the frontend.

---

[ scroll to repo-fund ]

>Let’s have a closer look at what we can do with this “find” method up here. Right now it just returns all the tasks from the database, but we can easily use it for paging.

---

[ limit:2, page: 2 ]
 
> If I tell “find” to limit the results to 2 items, 
I’ll get only 2 todos on the list, and if I say “page” - 2
I’ll get the second page. 

> These definitions go through the REST API request and into the database query on the backend.

---

[ order by ]

> We can also sort the list by any of the fields 
in ascending
>or descending order

---
[where]

> and we can also filter like this: 
> show me only the todos that are completed
> not completed
> or don’t filter.

--- 

> Now let’s see how, with Remult, I can add data validation to the Task entity, and have it affect both the frontend and the backend.

---

[ goto task.ts, validate ]

> So let’s go over to our Task entity and let’s send an “options” object to the title field decorator and say “validate”
and use a predefined “required” validator.

---

[ save and see error ]

> As soon as I’ve done that, if I’ll try to save an empty todo item, 
I’ll get an error message. 

--- 

[ clear network and retry]

> If I clear the network tab and try again, 
you can see there’s no request being sent to the backend because the validation check is done by javascript running in the browser. 

---

[ post request using new request, remember to choose post] 

> Now let’s try to bypass that by sending a POST request to the “tasks” API route with an empty title

> Doesn’t work and I get the same validation error from the API.

---

> Of course, you don’t have to use a predefined validator, you can use any arrow function to validate the data, 
so I can say for example 
“if task.title.length 
is less than 3 
throw “too short””. 

---

>Now, when I try to save 
I’m going to get the “too short” error both here
and in our API call

--- 

[ scroll to setAll, and demo click on set all ]

> Let’s look at the “setAllCompleted” function in the App component. It works but it’s not efficient, because it’s sending multiple requests to update all of these tasks. Let’s refactor this code to run on the backend instead.

---
[ add tasks controller ]

> Let’s create a new file in the “shared” folder a call it TasksController.ts. 
In it, I’ll define a TasksController class,

--- 
[ copy set all ]

> and let’s copy the code from the “setAll” function to this class. 

[adjust syntax ]

>Let’s make this a static method 

---

> and decorate it with the BackendMethod decorator from Remult.
> The BackendMethod decorator tells Remult that if I call this method from Frontend code, don’t run this code, but instead send an API request and run it on the backend.

--- 



[ and task repo]

 >All that’s left is to define a taskRepo just like before. 
 
 ---

 > and that’s it - we can use the same CRUD syntax both in Frontend code, to interact with the API, and in Backend code, to interact directly with the database.

---

[ register on index ]

> Let’s register the TasksController here.

[ call from app.tsx ]

> And now, in the App component, instead of this loop I can simply say: await TasksController.setAll(completed). That’s it.

--- 

[ demo click set all ]

> So now when I click “set all as completed” - I only get this one call to the backend. 

--- 
[ change set all parameter to string]


> One more important thing we get from this is type-safety for this API call, so if I try to send a string instead of a boolean here, TypeScript tells me I’ve made a mistake.

---

[ goto task.ts ]

> The last thing I want to show you is how to use Remult to control access to the REST API using simple, declarative code.

> Let’s say I want to restrict the API, so that only authenticated users can create, read and update tasks, 

---

[ allow.authenticate ]

> All I have to do is say here “allowApiCrud”-”Allow-authenticated”.

> As soon as I save this my page will fail because I’m not authenticated. 
> Let’s add a “sign-in” feature so we can make this app usable again.

---

[ goto backend/index.ts ]

>You can choose any way you like to implement an authentication flow. All you have to tell Remult is, how to extract the current user from any incoming request.

---

[ import session from “cookie-session”]

> For this demo I’m going to use the Express “cookie-session” middleware,

[ app.use(session({secret:” my secret”}); app.use(auth) ]

> I’ll add it here. 

---

> And I’ll use an “auth” route I’ve already prepared in this “auth.ts” file. Let’s have a look at it.
[ goto auth.ts ]

---

[ highlight valid users]

> We have a list of valid users

[ highlight signIn ]

> We have a signIn endpoint and a signOut endpoint. 

---

> Real-life authentication flows are much more complex than this, but for a demo this will have to do.

--- 

[ back to index.ts - get user]

> Next, I need to tell Remult how to extract the current user from a request. For that, I’ll set the getUser option here to a function that returns the “request.session.user”.

---

> Now let’s go back to the frontend and add user sign-in.

[ goto main.tsx ]

> To do that I’ll go to the main.tsx file and wrap the App component with an Auth component I’ve prepared in advance. 

---

[goto Auth.tsx]

> The “Auth” component is very simple, it has a currentUser state, signIn and signOut functions that call the API… really simple.

---

[ sign in as steve]

> Let’s try it out. I’ll sign in as “Steve”... now I can see the todos again, and I can update them.

--- 

>Let’s go back to the Task entity and add another restriction, only users who have an "admin" role can delete tasks.

> Now we Steve can add items, but he can't delete them.

---
[ goto auth.tsx ]
> Let's make Jane an admin
[ add roles["admin"]]

[Sign in as Jane]
> Now I’ll sign out and sign back in as Jane, and now I can delete.

---

> Well, there you have it. 
> Full CRUD operations across the stack  with no boilerplate, 
> end-to-end type-safety, 
> sharing code between Frontend  and Backend , 
> and a single-source-of-truth - our TypeScript entity. 

---

> These are the core features of Remult. 

[ url, remult.dev ]

> If you want to find out more, go to remult.dev. 

---

> Thanks for watching.
